package main

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"strings"
)

var outputWriter io.Writer
var keylogWriter io.Writer
var keylogFilename = flag.String("keylog", "", "write tls keys to file")
var outputFilename = flag.String("output", "", "set output file")
var forwardAddress = flag.String("forward", "", "forward requests to")

const VendorJuniper = 0xa4c
const VendorTGC = 0x5597
const Juniper1 = (VendorJuniper << 8) | 1

const EAPRequest uint8 = 1
const EAPResponse uint8 = 2
const EAPTypeTTLS = 0x15

func isStartTTLS(buf []byte) bool {

	if len(buf) < 0x18 {
		return false
	}

	ttlsStart := []byte{0x00, 0x00, 0x55, 0x97, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00}
	if buf[0x18] != EAPTypeTTLS {
		return false
	}

	return bytes.Compare(buf[0:len(ttlsStart)], ttlsStart) == 0
}

/* slower, by we can print/log everything */
func rawCopy(dst, src net.Conn, direction communicationDir) (err error) {
	buf := make([]byte, 32*1024)
	for {
		nr, err := src.Read(buf)
		if nr > 0 {
			_, _ = fmt.Fprintf(outputWriter, "Packet %s:\n%s", direction, hex.Dump(buf[0:nr]))

			if isStartTTLS(buf) {

			}

			nw, err := dst.Write(buf[0:nr])
			if err != nil {
				return err
			}

			if nr != nw {
				return io.ErrShortWrite
			}
		}
		if err != nil {
			if err == io.EOF {
				return nil
			}
			return err
		}
	}
}

func ioCopy(dst net.Conn, src net.Conn, direction communicationDir) {
	err := rawCopy(dst, src, direction)
	if err != nil {
		fmt.Fprintf(outputWriter, "%s: error from rawCopy: %s\n", direction, err)
	}
}

func handleClient(clientConn net.Conn) {
	defer clientConn.Close()

	config := tls.Config{KeyLogWriter: keylogWriter, InsecureSkipVerify: true}
	serverConn, err := tls.Dial("tcp", *forwardAddress, &config)
	if err != nil {
		fmt.Fprintf(outputWriter, "error initializing TLS connection: %s\n", err)
		return
	}

	defer serverConn.Close()

	go ioCopy(serverConn, clientConn, ClientToServer)
	ioCopy(clientConn, serverConn, ServerToClient)
}

func main() {
	var err error
	flag.Parse()

	if *forwardAddress == "" {
		fmt.Println("Forward address must be specified")
		flag.Usage()
		return
	}

	if !strings.Contains(*forwardAddress, ":") {
		newAddr := *forwardAddress + ":443"
		forwardAddress = &newAddr
	}

	outputWriter = os.Stdout
	if *outputFilename != "" {
		f, err := os.Create(*outputFilename)
		if err != nil {
			log.Fatalf("cannot open file: %s", err)
		}
		outputWriter = io.MultiWriter(os.Stdout, f)
		fmt.Println("Logging to", *outputFilename)
	}

	if *keylogFilename != "" {
		keylogWriter, err = os.OpenFile(*keylogFilename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
		if err != nil {
			fmt.Println("Cannot open keylog file:", err)
			return
		}
		fmt.Fprintf(keylogWriter, "# SSL/TLS secrets log file, generated by go\n")
		fmt.Println("Writing TLS keys to", *keylogFilename)
	}

	cert, err := tls.LoadX509KeyPair("/home/elias/cert.pem", "/home/elias/key.pem")
	if err != nil {
		log.Fatalf("server: loadkeys: %s", err)
	}
	config := tls.Config{Certificates: []tls.Certificate{cert}}
	config.Rand = rand.Reader
	service := "0.0.0.0:443"
	listener, err := tls.Listen("tcp", service, &config)
	if err != nil {
		log.Fatalf("server: listen: %s", err)
	}
	log.Printf("server: listening on %s for https, connects to https://%s", service, *forwardAddress)
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("server: accept: %s", err)
			break
		}
		defer conn.Close()
		log.Printf("server: accepted from %s", conn.RemoteAddr())
		go handleClient(conn)
	}
}
