package main

import (
	"bytes"
	"crypto/rand"
	"crypto/tls"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"strings"
)

var outputWriter io.Writer
var keylogWriter io.Writer
var keylogFilename = flag.String("keylog", "", "write tls keys to file")
var outputFilename = flag.String("output", "", "set output file")
var forwardAddress = flag.String("forward", "", "forward requests to")

const VendorJuniper = 0xa4c
const VendorTGC = 0x5597
const Juniper1 = (VendorJuniper << 8) | 1

const EAPRequest uint8 = 1
const EAPResponse uint8 = 2
const EAPTypeTTLS = 0x15

func isStartTTLS(buf []byte) bool {

	if len(buf) < 0x18 {
		return false
	}

	ttlsStart := []byte{0x00, 0x00, 0x55, 0x97, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00}
	if buf[0x18] != EAPTypeTTLS {
		return false
	}

	return bytes.Compare(buf[0:len(ttlsStart)], ttlsStart) == 0
}

type Proxy struct {
	clientConn net.Conn
	serverConn net.Conn

	// Channels for data received from client or server
	clientCh chan []byte
	serverCh chan []byte

	done chan struct{}
}

// Reader forwards all data from client to clientCh, or from server to serverCh
func NewProxy(clientConn, serverConn net.Conn) *Proxy {
	p := &Proxy{
		clientConn: clientConn,
		serverConn: serverConn,
		clientCh:   make(chan []byte),
		serverCh:   make(chan []byte),
		done:       make(chan struct{}),
	}

	return p
}

// Reader forwards all data from client to clientCh, or from server to serverCh
func (p *Proxy) Reader(direction communicationDir) error {
	var src net.Conn
	var ch chan []byte

	switch direction {
	case ClientToServer:
		src = p.clientConn
		ch = p.clientCh
	case ServerToClient:
		src = p.serverConn
		ch = p.serverCh
	}

	defer close(ch)

	buf := make([]byte, 32*1024)
	for {
		nr, err := src.Read(buf)
		if nr > 0 {
			ch <- buf[0:nr]
		}
		if err != nil {
			if err == io.EOF {
				return nil
			}
			return err
		}
	}
}

// CopyData reads data from the client and server channels and writes them to the correct connection
func (p *Proxy) CopyData() error {
	useTTLS := false

	for {
		var buf []byte
		var dst net.Conn
		var direction communicationDir

		select {
		case buf = <-p.clientCh:
			dst = p.serverConn
			direction = ClientToServer
			if useTTLS {

			}
		case buf = <-p.serverCh:
			dst = p.clientConn
			direction = ServerToClient

			if useTTLS {

			}
		case <-p.done:
			return nil
		}

		_, _ = fmt.Fprintf(outputWriter, "Packet %s:\n%s", direction, hex.Dump(buf))

		nb, err := dst.Write(buf)
		if err != nil {
			return err
		}

		if nb != len(buf) {
			return io.ErrShortWrite
		}
	}
}

func handleClient(clientConn net.Conn) error {
	defer clientConn.Close()

	config := tls.Config{KeyLogWriter: keylogWriter, InsecureSkipVerify: true}
	serverConn, err := tls.Dial("tcp", *forwardAddress, &config)
	if err != nil {
		err = fmt.Errorf("error initializing TLS connection: %w", err)
		return err
	}
	defer serverConn.Close()

	p := NewProxy(clientConn, serverConn)
	go func() {
		err = p.Reader(ClientToServer)
		if err != nil {
			fmt.Fprintf(outputWriter, "%s: error from reader: %s\n", ClientToServer, err)
		}
	}()

	go func() {
		err = p.Reader(ServerToClient)
		if err != nil {
			fmt.Fprintf(outputWriter, "%s: error from reader: %s\n", ServerToClient, err)
		}
	}()

	err = p.CopyData()
	return err
}

func main() {
	var err error
	flag.Parse()

	if *forwardAddress == "" {
		fmt.Println("Forward address must be specified")
		flag.Usage()
		return
	}

	if !strings.Contains(*forwardAddress, ":") {
		newAddr := *forwardAddress + ":443"
		forwardAddress = &newAddr
	}

	outputWriter = os.Stdout
	if *outputFilename != "" {
		f, err := os.Create(*outputFilename)
		if err != nil {
			log.Fatalf("cannot open file: %s", err)
		}
		outputWriter = io.MultiWriter(os.Stdout, f)
		fmt.Println("Logging to", *outputFilename)
	}

	if *keylogFilename != "" {
		keylogWriter, err = os.OpenFile(*keylogFilename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
		if err != nil {
			fmt.Println("Cannot open keylog file:", err)
			return
		}
		fmt.Fprintf(keylogWriter, "# SSL/TLS secrets log file, generated by go\n")
		fmt.Println("Writing TLS keys to", *keylogFilename)
	}

	cert, err := tls.LoadX509KeyPair("/home/elias/cert.pem", "/home/elias/key.pem")
	if err != nil {
		log.Fatalf("server: loadkeys: %s", err)
	}
	config := tls.Config{Certificates: []tls.Certificate{cert}}
	config.Rand = rand.Reader
	service := "0.0.0.0:443"
	listener, err := tls.Listen("tcp", service, &config)
	if err != nil {
		log.Fatalf("server: listen: %s", err)
	}
	log.Printf("server: listening on %s for https, connects to https://%s", service, *forwardAddress)
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("server: accept: %s", err)
			break
		}
		defer conn.Close()
		log.Printf("server: accepted from %s", conn.RemoteAddr())
		go func() {
			err = handleClient(conn)
			if err != nil {
				fmt.Fprintf(outputWriter, "error from handleClient: %s\n", err)
			}
		}()
	}
}
